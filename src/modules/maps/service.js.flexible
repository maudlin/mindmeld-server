const { z } = require('zod');
const { randomUUID } = require('crypto');
const MapsRepo = require('./repo');
const { NotFoundError, ConflictError, BadRequestError } = require('./errors');

const MapCreateSchema = z
  .object({
    name: z.string().min(1),
    data: z.object({}).passthrough().optional(),
    state: z.object({}).passthrough().optional()
  })
  .refine(v => v.data || v.state, {
    message: 'Invalid create request: missing data',
    path: ['data']
  })
  .refine(v => {
    // Check for double-wrapped data in either data or state fields
    const payload = v.data || v.state;
    if (payload && payload.data) {
      return false; // Reject if data contains nested "data" field
    }
    return true;
  }, {
    message: 'Double-wrapped data structure detected - this indicates a client-side bug',
    path: ['data']
  });

const MapUpdateSchema = z
  .object({
    data: z.object({}).passthrough().optional(),
    state: z.object({}).passthrough().optional(),
    version: z.number().int().min(1)
  })
  .refine(v => v.data || v.state, {
    message: 'Invalid update request: missing data',
    path: ['data']
  })
  .refine(v => {
    // Check for double-wrapped data in either data or state fields
    const payload = v.data || v.state;
    if (payload && payload.data) {
      return false; // Reject if data contains nested "data" field
    }
    return true;
  }, {
    message: 'Double-wrapped data structure detected - this indicates a client-side bug',
    path: ['data']
  });

class MapsService {
  constructor(sqliteFile) {
    this.repo = new MapsRepo(sqliteFile);
  }

  create({ name, data, state }) {
    const parsed = MapCreateSchema.safeParse({ name, data, state });
    if (!parsed.success) {
      const error = new BadRequestError('Invalid create request');
      error.zodErrors = parsed.error.errors;
      throw error;
    }
    const payload = parsed.data.data ?? parsed.data.state;
    const id = randomUUID();
    const version = 1;
    const updatedAt = new Date().toISOString();
    const stateJson = JSON.stringify(payload);
    const sizeBytes = Buffer.byteLength(stateJson, 'utf8');
    const result = this.repo.create({
      id,
      name,
      version,
      updatedAt,
      stateJson,
      sizeBytes
    });
    return result;
  }

  getById(id) {
    const result = this.repo.getById(id);
    if (!result) {
      throw new NotFoundError('Map not found');
    }
    return result;
  }

  list() {
    return this.repo.list();
  }

  update(id, { data, state, version }) {
    const parsed = MapUpdateSchema.safeParse({ data, state, version });
    if (!parsed.success) {
      const error = new BadRequestError('Invalid update request');
      error.zodErrors = parsed.error.errors;
      throw error;
    }

    const existing = this.repo.getById(id);
    if (!existing) {
      throw new NotFoundError('Map not found');
    }

    if (existing.version !== version) {
      throw new ConflictError('Version conflict');
    }

    const payload = parsed.data.data ?? parsed.data.state;
    const newVersion = version + 1;
    const updatedAt = new Date().toISOString();
    const stateJson = JSON.stringify(payload);
    const sizeBytes = Buffer.byteLength(stateJson, 'utf8');

    const result = this.repo.update(id, {
      version: newVersion,
      updatedAt,
      stateJson,
      sizeBytes
    });

    return result;
  }

  delete(id) {
    const existing = this.repo.getById(id);
    if (!existing) {
      throw new NotFoundError('Map not found');
    }
    return this.repo.delete(id);
  }
}

module.exports = MapsService;
